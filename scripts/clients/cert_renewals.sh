#!/bin/bash
# Internal certificate renewal script for lilikoi
# Uses AppRole auth to access Vault

set -e

# Configuration
LOG_FILE="/var/log/vault-clients/cert-renewal.log"
CERT_DIR="/etc/vault-clients/certificates"
CONFIG_DIR="/etc/vault-clients"
mkdir -p "$(dirname "$LOG_FILE")" "$CERT_DIR" "$CONFIG_DIR"

# Function to log messages
log() {
    echo "[$(date)] $1" | tee -a "$LOG_FILE"
}

# Colorful output
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Read credentials from file generated by Terraform
if [ -f "$CONFIG_DIR/client_credentials.json" ]; then
    log "Reading credentials from file"
    ROLE_ID=$(jq -r '.certificate_renewal.role_id' "$CONFIG_DIR/client_credentials.json")
    SECRET_ID=$(jq -r '.certificate_renewal.secret_id' "$CONFIG_DIR/client_credentials.json")
    NAMESPACE=$(jq -r '.certificate_renewal.namespace' "$CONFIG_DIR/client_credentials.json")
else
    # Fallback to environment variables
    log "Using environment variables for credentials"
    ROLE_ID=${VAULT_ROLE_ID:-""}
    SECRET_ID=${VAULT_SECRET_ID:-""}
    NAMESPACE=${VAULT_NAMESPACE:-"admin/client_population/pki-internal"}
fi

VAULT_ADDR=${VAULT_ADDR:-"https://vault.example.com:8200"}

# Service names to generate certificates for
SERVICES=("api-service" "auth-service" "data-service")
DNS_NAMES=("api.service.internal" "auth.service.internal" "data.service.internal")
IP_ADDRESSES=("10.0.0.101" "10.0.0.102" "10.0.0.103")

log "Starting internal certificate renewal with AppRole auth"
log "Vault address: $VAULT_ADDR"
log "Namespace: $NAMESPACE"

# Login with AppRole
log "Authenticating with AppRole"
VAULT_TOKEN=$(curl -s \
    --request POST \
    --header "X-Vault-Namespace: $NAMESPACE" \
    --data "{\"role_id\":\"$ROLE_ID\",\"secret_id\":\"$SECRET_ID\"}" \
    "$VAULT_ADDR/v1/auth/approle/login" | jq -r '.auth.client_token')

if [ -z "$VAULT_TOKEN" ] || [ "$VAULT_TOKEN" == "null" ]; then
    log "${RED}Authentication failed!${NC}"
    exit 1
fi

log "${GREEN}Authentication successful!${NC}"

# Function to renew a certificate
renew_certificate() {
    local service_name=$1
    local dns_name=$2
    local ip_address=$3
    
    log "${BLUE}Renewing certificate for $service_name ($dns_name)...${NC}"
    
    # Prepare certificate request data
    REQUEST_DATA=$(cat <<EOF
{
  "common_name": "$dns_name",
  "alt_names": ["$service_name.internal", "$service_name.service.internal"],
  "ip_sans": "$ip_address",
  "uri_sans": "uri:service:$service_name",
  "ttl": "72h"
}
EOF
)
    
    # Request certificate from Vault
    CERT_RESPONSE=$(curl -s \
        --header "X-Vault-Token: $VAULT_TOKEN" \
        --header "X-Vault-Namespace: $NAMESPACE" \
        --request POST \
        --data "$REQUEST_DATA" \
        "$VAULT_ADDR/v1/pki/issue/internal")
    
    if [ $? -ne 0 ] || [ -z "$CERT_RESPONSE" ]; then
        log "${RED}Failed to issue certificate for $service_name!${NC}"
        return 1
    fi
    
    # Extract certificate, private key, and CA
    CERTIFICATE=$(echo "$CERT_RESPONSE" | jq -r '.data.certificate')
    PRIVATE_KEY=$(echo "$CERT_RESPONSE" | jq -r '.data.private_key')
    ISSUING_CA=$(echo "$CERT_RESPONSE" | jq -r '.data.issuing_ca')
    SERIAL_NUMBER=$(echo "$CERT_RESPONSE" | jq -r '.data.serial_number')
    
    if [ -z "$CERTIFICATE" ] || [ "$CERTIFICATE" == "null" ]; then
        log "${RED}Failed to extract certificate from response for $service_name!${NC}"
        return 1
    fi
    
    # Save certificates and keys
    echo "$CERTIFICATE" > "$CERT_DIR/$service_name.crt"
    echo "$PRIVATE_KEY" > "$CERT_DIR/$service_name.key"
    echo "$ISSUING_CA" > "$CERT_DIR/$service_name.ca.crt"
    
    # Set proper permissions
    chmod 644 "$CERT_DIR/$service_name.crt" "$CERT_DIR/$service_name.ca.crt"
    chmod 600 "$CERT_DIR/$service_name.key"
    
    # Save metadata for tracking
    echo "{\"service\": \"$service_name\", \"dns_name\": \"$dns_name\", \"serial_number\": \"$SERIAL_NUMBER\", \"renewal_date\": \"$(date -Iseconds)\"}" \
        > "$CERT_DIR/$service_name.meta.json"
    
    log "${GREEN}Certificate for $service_name successfully renewed!${NC}"
    log "  Serial Number: $SERIAL_NUMBER"
    log "  Saved to: $CERT_DIR/$service_name.crt"
    
    # Simulate notifying the service to reload its certificate
    log "${YELLOW}Notifying $service_name to reload certificate...${NC}"
    sleep 1  # Simulate notification time
    
    return 0
}

# Renew certificates for all services
SUCCESS_COUNT=0
for i in "${!SERVICES[@]}"; do
    renew_certificate "${SERVICES[$i]}" "${DNS_NAMES[$i]}" "${IP_ADDRESSES[$i]}"
    if [ $? -eq 0 ]; then
        SUCCESS_COUNT=$((SUCCESS_COUNT + 1))
    fi
done

# Summary
log "================================================"
log "Certificate renewal summary:"
log "  Total services: ${#SERVICES[@]}"
log "  Successful renewals: $SUCCESS_COUNT"
log "  Failed renewals: $((${#SERVICES[@]} - $SUCCESS_COUNT))"

if [ $SUCCESS_COUNT -eq ${#SERVICES[@]} ]; then
    log "${GREEN}All certificates renewed successfully!${NC}"
else
    log "${YELLOW}Some certificate renewals failed. Check the logs for details.${NC}"
fi

# Display fancy completion message
cat << "EOF"
  ____          _   _  __ _           _            
 / ___|___ _ __| |_(_)/ _(_) ___ __ _| |_ ___  ___ 
| |   / _ \ '__| __| | |_| |/ __/ _` | __/ _ \/ __|
| |__|  __/ |  | |_| |  _| | (_| (_| | ||  __/\__ \
 \____\___|_|   \__|_|_| |_|\___\__,_|\__\___||___/
                                                   
 ____                                _             
|  _ \ ___ _ __   _____      _____  __| |          
| |_) / _ \ '_ \ / _ \ \ /\ / / _ \/ _` |          
|  _ <  __/ | | |  __/\ V  V /  __/ (_| |          
|_| \_\___|_| |_|\___| \_/\_/ \___|\__,_|          
                                                   
EOF

# Cleanup
exit 0